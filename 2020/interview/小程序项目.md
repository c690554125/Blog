## 小程序项目

### 承担的角色

项目管理：
初期

- 该项目的商业模式的调研，参考市场已有产品。
- 查阅微信官方文档，了解第三方平台如何创建到发布。
- 整理收集的资料和产品探讨，确定我司产品的初步形态，同步信息给关键人员明确初步需求。
- 初步需求评审，确认需求合理性，确认最终需求，以及相关人员的工作排期。

中期

- 每日项目晨会，了解相关工作人员的工作进度，收集问题，评估风险，做出相应的调整。
- 周会做总结，同步信息给相关人员。

后期

- 发布前 3 天提前准备上线工作，通知相关开发人员准备好发布计划。
- 发布后组织复盘会议，讨论该项目中的问题。

### 工程方面

1.  **优化开发真机预览流程：**原本 dev watch 模式下资源包超出 2MB，无法在开发者工具预览，pro + watch 会压缩代码，但会导致开发阶段编译+压缩时间很久。

配合 gulp + 微信开发者工具的钩子

2.  **优化开发流程，避免繁琐环境配置：**开发环境复杂，小程序模板开发方式不同于传统小程序开发方式，我们为了开发和生产，搞了 2 套模板和平台。配置成本增加一倍。模板开发模式和传统开发模式还要并存，这也会导致的调用的接口不同。手动切换出错频率高。

借鉴前端 client 脚手架的形式，引入`inquirer`库，问询的方式将复杂的配置逻辑变得简单，然后根据结果来动态修改本地配置文件。

### 开发效率

1. **复用页面逻辑和组件** 小程序每个`page`是单独的`webview`渲染的，所以复用逻辑和组件需要在每个`page`单独去写，无法实现类似`web`开发，将公用组件挂载在`Body`之下得到大量复用。

即便形成组件的话，也依旧需要在每个页面单独导入使用。

利用`HOC`和`反向继承`。

基于`HOC`创建一个通用的`page`页面，包含组件，如`alert`，以及状态，如`loading`，接收每个的`page`作为参数。
利用`反向继承`让通用页面组件继承每个`page`，这么做的目的是为了让每个页面自己的生命周期方法正常调用，不反向继承的话，则会去调通用`page`页面的声明周期方法，而我们又不能将每个页面的不同的声明周期逻辑放在通用`page`组件中。

这里需要注意的是调用父类的`super.render()`方法，以渲染每个页面的内容到通用页面组件中。

### 业务问题

1. 小程序中瀑布流，需要实现两列高度均匀，不能实时计算每个项的高度，因为在小程序中计算高度是异步的，而且性能消耗很大。

在我的业务场景，我的列表项只有 2 种，高度也只有 2 种，两种类型列表项的高度差也固定。结合这个特点，我的做法是：两个瀑布流，分为 2 个数组，接口调用获取原始列表数据通过取余运算决定塞入哪个瀑布流数组中，根据接口返回参数判断是否还有更多的数据，如果没有更多，则在最后一次渲染完瀑布流数据后，对瀑布流高度求解，得到最短和最高的 index，决定将最高的瀑布流数组中最后一个数据移动到最短的瀑布流数组中；移动前还需要判断 高度差是否 大于 需要被移动的这个 item 高度，大于，则需要移动，小于，则不需要移动。 保持高度均匀即可。

这个算法中我只需要求解 2 次 dom 的高度，一次是瀑布流高度，一次是被移动的列表项高度。

2. 微信小程序的 IOS 和安卓的 socket 异常事件触发机制不同。
   1. IOS 和安卓在触发断网后重连的机制不一样，断网后都触发 onClose，然后重连，重连失败时，IOS 触发 onClose 和 onError，安卓触发 onError。
   2. IOS 和安卓在断网的情况下，调用 ws 实例的 send 方法，IOS 会走 fail 回调，安卓会走 success 回调。

会导致在进行心跳，以及发送 ws 消息时表现不一致，出现各种逻辑问题。封装了一个适用于微信小程序的 ws 库。
