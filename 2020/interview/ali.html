<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>阿里笔试题</title>
  </head>
  <body>
    <script>
      // (function () {
      //   // 辅助方法：判断鸭子类型
      //   function duckPromise(obj) {
      //     if (obj && obj.then && typeof obj.then === "function") {
      //       return true;
      //     }
      //     return false;
      //   }

      //   // 辅助方法：判断真实类型
      //   function isType(target, type) {
      //     const targetType = Object.prototype.toString.call(target);
      //     return type.toLowerCase() === targetType.slice(7, -1).toLowerCase();
      //   }

      //   function race(arr) {
      //     return new Promise((resolve, reject) => {
      //       for (let v of arr) {
      //         if (duckPromise(v) || isType(v, "promise")) {
      //           v.then((r) => {
      //             resolve(r);
      //           }).catch((e) => {
      //             reject(e);
      //           });
      //         }
      //       }
      //     });
      //   }

      //   var p1 = new Promise((resolve, reject) => {
      //     setTimeout(() => {
      //       reject(new Error("hello"));
      //     }, 1000);
      //   });

      //   var p2 = new Promise((resolve) => {
      //     setTimeout(() => {
      //       resolve(2);
      //     }, 2000);
      //   });

      //   race([p1, p2])
      //     .then((r) => {
      //       console.log(r);
      //     })
      //     .catch((e) => {
      //       console.log(e);
      //     });
      // })();
    </script>
    <script>
      (function() {
        class MergeReqAndCache {
          delay(t) {
            return new Promise(resolve => {
              setTimeout(() => {
                resolve(true);
              }, t);
            });
          }

          // 返回一个函数
          // 具备缓存，具备多次调用合并
          wrapFn(fn) {
            const cacheRes = {};
            return async function wrappedFn() {
              const args = arguments;
              const key = [].slice.call(args).toString();
              // 有缓存值，直接返回
              if (cacheRes[key] !== undefined) {
                return await Promise.resolve(cacheRes[key]);
              } else {
                const r = await fn.apply(this, args);
                cacheRes[key] = r;
                return r;
              }
            };
          }
        }

        // 测试
        const cacheIns = new MergeReqAndCache();

        function get() {
          return new Promise(resolve => {
            setTimeout(() => {
              resolve(arguments[0]);
            }, 1000);
          });
        }

        const newGet = cacheIns.wrapFn(get);

        newGet(1).then(r => {
          console.log('r1', r);
        });

        setTimeout(() => {
          newGet(1).then(r => {
            console.log('r2', r);
          });
        }, 2000);
      })();
    </script>
  </body>
</html>
