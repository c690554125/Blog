<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>阿里笔试题</title>
  </head>
  <body>
    <script>
      // (function () {
      //   // 辅助方法：判断鸭子类型
      //   function duckPromise(obj) {
      //     if (obj && obj.then && typeof obj.then === "function") {
      //       return true;
      //     }
      //     return false;
      //   }

      //   // 辅助方法：判断真实类型
      //   function isType(target, type) {
      //     const targetType = Object.prototype.toString.call(target);
      //     return type.toLowerCase() === targetType.slice(7, -1).toLowerCase();
      //   }

      //   function race(arr) {
      //     return new Promise((resolve, reject) => {
      //       for (let v of arr) {
      //         if (duckPromise(v) || isType(v, "promise")) {
      //           v.then((r) => {
      //             resolve(r);
      //           }).catch((e) => {
      //             reject(e);
      //           });
      //         }
      //       }
      //     });
      //   }

      //   var p1 = new Promise((resolve, reject) => {
      //     setTimeout(() => {
      //       reject(new Error("hello"));
      //     }, 1000);
      //   });

      //   var p2 = new Promise((resolve) => {
      //     setTimeout(() => {
      //       resolve(2);
      //     }, 2000);
      //   });

      //   race([p1, p2])
      //     .then((r) => {
      //       console.log(r);
      //     })
      //     .catch((e) => {
      //       console.log(e);
      //     });
      // })();
    </script>
    <script>
      (function() {
        class MergeReqAndCache {
          constructor() {
            this.timer = null;
            this.mergeParamsFn = {};
            this.cacheParams = [];
          }

          delay(t) {
            return new Promise(resolve => {
              setTimeout(() => {
                resolve(true);
              }, t);
            });
          }

          // 合并处理函数
          // 并发执行时，只执行最后一次。
          mergeFn(mergeFnName) {
            return new Promise(resolve => {
              clearTimeout(this.timer);
              this.timer = setTimeout(async () => {
                // 合并多个函数后，真正执行的最后一个函数。
                // 收集的参数深复制
                const copyParams = JSON.parse(JSON.stringify(this.cacheParams));
                // 重置收集参数
                this.cacheParams = [];
                const r = await this.mergeParamsFn[mergeFnName](...copyParams);
                resolve(r);
              }, 0);
            });
          }

          // 返回一个函数
          // 具备缓存，具备多次调用合并
          // mergeFn?: {fn: Function, name?: string}
          wrapFn(fn, mergeFn) {
            const _this = this;
            const cacheRes = {};
            // 注册fn函数配对的合并处理函数
            let name = '';
            if (mergeFn && mergeFn.fn) {
              name = mergeFn.name || fn.name;
              this.mergeParamsFn[name] = mergeFn.fn;
            }
            return async function wrappedFn() {
              const args = [].slice.call(arguments);
              // 收集参数
              _this.cacheParams.push(args);

              await _this.delay(0);

              // 多个任务的参数收集，走合并处理函数
              if (_this.cacheParams.length > 1 && name) {
                if (!name) {
                  console.log('缺少配对的合并处理函数');
                  return;
                }
                const mergeRes = await _this.mergeFn(name, _this.cacheParams);
                return mergeRes;
              } else {
                // 单独调用，重置收集的参数
                _this.cacheParams = [];
                const key = args.toString();
                // 有缓存值，直接返回
                if (cacheRes[key] !== undefined) {
                  return await Promise.resolve(cacheRes[key]);
                } else {
                  const r = await fn.apply(this, args);
                  cacheRes[key] = r;
                  return r;
                }
              }
            };
          }
        }

        // 测试
        const cacheIns = new MergeReqAndCache();

        function get() {
          return new Promise(resolve => {
            setTimeout(() => {
              resolve(arguments[0]);
            }, 1000);
          });
        }

        function gets() {
          return new Promise(resolve => {
            setTimeout(() => {
              resolve([].slice.call(arguments));
            }, 1000);
          });
        }

        // const newGets = cacheIns.wrapFn(gets);

        const newGet = cacheIns.wrapFn(get, {
          name: 'gets',
          fn: gets
        });

        newGet('a1').then(r => {
          console.log('r1', r);
        });

        newGet('a2').then(r => {
          console.log('r2', r);
        });

        // 测缓存
        setTimeout(() => {
          newGet('b1').then(r => {
            console.log('r3', r);
          });
        }, 2000);

        // 测合并缓存
        setTimeout(() => {
          newGet('c1').then(r => {
            console.log('r4', r);
          });
          newGet('b2').then(r => {
            console.log('r5', r);
          });
        }, 3000);
      })();
    </script>
  </body>
</html>
