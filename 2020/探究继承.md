# 探究继承

JS 世界的继承如何实现，原型在继承中的作用，以前的继承和现在的继承。

## 原型查找机制

JS 中继承依赖原型实现，访问一个实例不存在的属性时，会去实例的原型对象上查找。

```js
function Parent() {}
Parent.prototype.run = true;
var person = new Parent();
person.run; // true
```

如果实例原型上不存在，则会去实例原型的原型上查找，以此类推直到**原型顶端，也就是 null**。

```js
var a = {};
a.__proto__; // Object.prototype
a.__proto__.__proto__; // 也就是 Object.prototype.__proto__  = null
```

JS 中一切皆对象，函数也是对象，我们看看函数的**原型链**（原型-原型-原型-...这种链式，被称为原型链）

```js
function b() {}
b.__proto__ === Function.prototype; // true f () { [native code] } 也就是 Function.prototype
b.__proto__.__proto__ === Object.prototype; // true 也就是Function.prototype.__proto__，别忘了Function.prototype也是对象，所以其原型是 Object.prototype。这也说明了，JS中一切皆对象！
b.__proto__.__proto__.__proto__ === null; // true Object.prototype.__proto__ === null 到头了
```

配合 JS 原型链查找机制，因此出现了 JS 版本的继承。

## new 实例化

JS 中通过`构造函数`来模拟类，通过`prototype`来模拟继承。类的实例化则需要用`new`关键字，`new F()`。我们看看`new`做了些什么：

```js
function Person() {}
var a = new Person();
```

目前我们就看到`new`做了三件事：

1. 创建了一个新的对象
2. 返回了该对象\*\*赋值给了`a变量`。
3. 并且 a 实例的`[[Prototype]]`关联到了`Person.prototype`，我们可以通过 a.xx 访问到`Person.prototype`的方法和属性，还记得吧！

因为构造函数模拟了类，类是可以有属性和方法的，我们来给上面的`Person`类加点料

```js
function Person(name) {
  this.name = name; // 类属性
  this.sayHi = function () {
    // 类方法
    console.log(`Hi ${this.name}`);
  };
}

var a = new Person('Jack');
a.name; // Jack
a.sayHi(); // Hi Jack

var b = new Person('Loose');
b.name; // Loose
b.sayHi(); // Hi Loose
```

可以看到，通过`Person`类，我们声明了 2 个实例 `a 和 b`，分别访问 `name` 和 `sayHi` 方法，使用了实例自己的 `name` 值，所以`Person`类在实例化时，里面的 `this` 指向了实例对象。

所以`new`一共做了四件事。

4. 实例化时将 this 指向新的对象。

## 谁继承谁

只有一个类，谈不上继承，至少需要一个父类，一个子类继承父类。JS 继承依赖的是原型，请牢记！

接着，先看一个错误的例子

```js
function Parent() {}
function Son() {}
Son.prototype = Parent.prototype; // 这不是继承，这是赤裸裸的让子类原型 和 父类原型 指向同一个对象。
Son.prototype.constructor = Son; // 纠正上面一行导致constructor被改写的问题，让它指向正确值

var son = new Son();
son.constructor === Son; // true 没问题，毕竟上面重写了constructor
son.__proto__ === Son.prototype; // true
son.__proto__ === Parent.prototype; // true
son.__proto__.__proto__ === Object.prototype; // true

// 而且
var parent = new Parent();
parent.constructor === Parent; // false 因为父子类原型都相等了，且上Son.prototype.constructor = Son，导致父类实例现在出问题了。
```

上面的例子并没有体现`Son`继承了`Parent`，而是直接让父子类的原型相等了，还导致父类实例的`constructor`指向到了`Son`上，完全错误！

原型继承要达到的是子类原型 继承自 父类的原型，也就是`son.__proto__.__proto__ === Parent.prototype`，且父类实例和子类实例的`constructor`都要指向正确的值才对。

我们看看正确的写法

```js
function Parent() {}
function Son() {}
Son.prototype = new Parent(); // 这里实现继承！new Parent()返回了一个对象，这里是一个空的{}，但是其原型指向的时Parent.prototype对象哦，也就是{constructor: Parent}
Son.prototype.constructor = Son;

var son = new Son();
son.constructor === Son; // true
son.__proto__ === Son.prototype; // true
son.__proto__.__proto__ === Parent.prototype; // true

var parent = new Parent();
parent.constructor === Parent; // true
```

这下没问题了，可以看到`son`实例的原型指向`Son类`，而`Son类`又继承自`Parent类`。各自类实例的`constructor`指向也正确。

## 继承版本演进
