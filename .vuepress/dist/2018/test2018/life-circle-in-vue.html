<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue中的钩子 | tkgkn</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.c4fe0140.css" as="style"><link rel="preload" href="/assets/js/app.42da6a3b.js" as="script"><link rel="preload" href="/assets/js/2.756098eb.js" as="script"><link rel="preload" href="/assets/js/17.e2888c6c.js" as="script"><link rel="prefetch" href="/assets/js/10.0db9db61.js"><link rel="prefetch" href="/assets/js/11.b6716d1a.js"><link rel="prefetch" href="/assets/js/12.ce3afffc.js"><link rel="prefetch" href="/assets/js/13.6d2628e8.js"><link rel="prefetch" href="/assets/js/14.cff14ea8.js"><link rel="prefetch" href="/assets/js/15.e969f5ca.js"><link rel="prefetch" href="/assets/js/16.82aab1c4.js"><link rel="prefetch" href="/assets/js/18.a2304c61.js"><link rel="prefetch" href="/assets/js/19.3f9e1b2b.js"><link rel="prefetch" href="/assets/js/20.53d0731c.js"><link rel="prefetch" href="/assets/js/21.8af80508.js"><link rel="prefetch" href="/assets/js/22.d8142cca.js"><link rel="prefetch" href="/assets/js/3.d0fa378b.js"><link rel="prefetch" href="/assets/js/4.1d7c24a6.js"><link rel="prefetch" href="/assets/js/5.8278fb1d.js"><link rel="prefetch" href="/assets/js/6.e64326bf.js"><link rel="prefetch" href="/assets/js/7.f7cf7588.js"><link rel="prefetch" href="/assets/js/8.f22e7bdb.js"><link rel="prefetch" href="/assets/js/9.9f7d13a8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c4fe0140.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">tkgkn</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/2018/test2018/.html" class="nav-link">
  GitHub
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/2018/test2018/.html" class="nav-link">
  GitHub
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>2018</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/2018/about-select-element.html" class="sidebar-link">about-select-element</a></li><li><a href="/2018/async-sync.html" class="sidebar-link">async-sync</a></li><li><a href="/2018/event-loop.html" class="sidebar-link">event-loop</a></li><li><a href="/2018/less-module-in-webpack.html" class="sidebar-link">less-module-in-webpack</a></li><li><a href="/2018/life-circle-in-vue.html" class="sidebar-link">life-circle-in-vue</a></li><li><a href="/2018/promise.html" class="sidebar-link">promise</a></li><li><a href="/2018/render-in-vue.html" class="sidebar-link">render-in-vue</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>test2018</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/2018/test2018/about-select-element.html" class="sidebar-link">about-select-element</a></li><li><a href="/2018/test2018/async-sync.html" class="sidebar-link">async-sync</a></li><li><a href="/2018/test2018/event-loop.html" class="sidebar-link">event-loop</a></li><li><a href="/2018/test2018/less-module-in-webpack.html" class="sidebar-link">less-module-in-webpack</a></li><li><a href="/2018/test2018/life-circle-in-vue.html" aria-current="page" class="active sidebar-link">life-circle-in-vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/2018/test2018/life-circle-in-vue.html#错误案例" class="sidebar-link">错误案例</a></li><li class="sidebar-sub-header"><a href="/2018/test2018/life-circle-in-vue.html#生命周期钩子" class="sidebar-link">生命周期钩子</a></li><li class="sidebar-sub-header"><a href="/2018/test2018/life-circle-in-vue.html#路由守卫" class="sidebar-link">路由守卫</a></li><li class="sidebar-sub-header"><a href="/2018/test2018/life-circle-in-vue.html#全局型" class="sidebar-link">全局型</a></li><li class="sidebar-sub-header"><a href="/2018/test2018/life-circle-in-vue.html#单个路由独享守卫" class="sidebar-link">单个路由独享守卫</a></li><li class="sidebar-sub-header"><a href="/2018/test2018/life-circle-in-vue.html#组件内调用守卫" class="sidebar-link">组件内调用守卫</a></li><li class="sidebar-sub-header"><a href="/2018/test2018/life-circle-in-vue.html#导航完整的解析流程" class="sidebar-link">导航完整的解析流程</a></li></ul></li><li><a href="/2018/test2018/promise.html" class="sidebar-link">promise</a></li><li><a href="/2018/test2018/render-in-vue.html" class="sidebar-link">render-in-vue</a></li><li><a href="/2018/test2018/thread-process.html" class="sidebar-link">thread-process</a></li></ul></section></li><li><a href="/2018/thread-process.html" class="sidebar-link">thread-process</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue中的钩子"><a href="#vue中的钩子" class="header-anchor">#</a> Vue中的钩子</h1> <p>单页面应用通常都会用到vue-router，在一个组件或者页面被展示或销毁时，生命周期钩子和路由守卫协作搭配，能够时刻控制组件和页面在不同阶段触发我们自己的函数。然而，分清楚生命周期和路由守卫各自的使用场景很重要，不能混为一谈。未区分清楚，就容易犯错，如下场景案例，都是我犯错的真实案例。</p> <h2 id="错误案例"><a href="#错误案例" class="header-anchor">#</a> 错误案例</h2> <p>如下实际工作中用错的案例。</p> <h3 id="错用场景1"><a href="#错用场景1" class="header-anchor">#</a> 错用场景1</h3> <p>A页面(组件)中打开了A-1页面(组件)，然后由A-1页面返回到A页面，在A页面的<code>activated</code>钩子中写了函数，期待能够在A-1返回至A时触发，事实是没有触发，因为没有弄清楚<code>activated</code>钩子函数的触发场景，这里实际应该用路由守卫来触发。</p> <h3 id="错用场景2"><a href="#错用场景2" class="header-anchor">#</a> 错用场景2</h3> <p>Home页面中打开A页面，A页面返回Home页面。
Home页面中打开B页面，B页面返回Home页面。
以上操作，需要在进入A,B页面时根据页面更改title为A或B，均需要在返回Home页面时，在把title改为home。我在Home，A，B三个组件中写了<code>beforeRouteEnter</code>守卫，挂载了修改title的函数。然后只有A，B有效，Home只有在初次进入时有效。没有弄清楚操作行为B-&gt;Home，A-&gt;Home不属于<code>beforeRouteEnter</code>，路由变化是这样的: <code>/home/A</code>-&gt;<code>/home</code>。
解决方式：Home组件中使用<code>beforeRouteUpdate</code>，判断<code>to.path === '/home'</code>触发修改title。A,B组件中使用<code>beforeRouteLeave</code>判断<code>to.path === '/home'</code>触发修改title。或者在<code>beforeEach</code>中对路由的各个操作做判断。</p> <h2 id="生命周期钩子"><a href="#生命周期钩子" class="header-anchor">#</a> 生命周期钩子</h2> <p>生命周期钩子是比较常用的，不管是在根实例还是在单文件组件中。都经常会用到。</p> <h3 id="写法注意"><a href="#写法注意" class="header-anchor">#</a> 写法注意</h3> <p>所有钩子函数，自动绑定this（实例本身）。所以不能使用箭头函数，箭头函数绑定的this是父作用域。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 注意，这里是最简单的引用vue.js后，然后直接在全局实例化Vue</span>
<span class="token comment">// 因此var vm 等同于window.vm</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// right</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token punctuation">}</span>

  <span class="token comment">// 上面写法等同于如下写法</span>
  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// this指向Vue实例本身</span>
  <span class="token punctuation">}</span>


  <span class="token comment">// error 这种写法错误</span>
  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 箭头函数绑定的是父作用域，这个例子中this指向window</span>
    <span class="token comment">// 因此箭头函数的话this指向并不是你期待的</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="生命周期函数"><a href="#生命周期函数" class="header-anchor">#</a> 生命周期函数</h3> <p><strong>beforeCreate</strong>：实例初始化之后，实例还没有创建完成，因此访问this的话，是undefined。</p> <p><strong>created</strong>：实例创建完成，但是未完成DOM挂载。因此this.$el是访问不到的。这里可以执行watch，methods等方法了。常用来挂载页面数据初始化（不涉及到DOM操作）。</p> <blockquote><p>涉及到dom挂载，挂载后的重新打补丁渲染，销毁等钩子，都不会在服务端渲染阶段被调用。可以理解，因为服务端只会对页面做一次初始化，按照初始渲染，生成HTML，发送到客户端（浏览器端）。这块猜测如此，后期学习ssr方式后验证。</p></blockquote> <p><strong>beforeMount</strong>：在挂载DOM到之前的一个钩子函数。能访问到this.$el，就是需要挂载的元素DOM（原始模板）。<strong>注意</strong>：$el即挂载的根节点，如<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，如单文件组件<code>&lt;template&gt;&lt;div&gt;&lt;/div&gt;&lt;/template&gt;</code>中的div根节点。如果是单文件的方式，在组建中beforeMount不一定能获取到$el，官方文档在<strong>mounted</strong>钩子函数中有说明。</p> <blockquote><p>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。</p></blockquote> <p><strong>mounted</strong>：el选项被新创建的$el替换，且$el挂载到实例上之后（即vm.$el），调用该钩子。通常会在该钩子阶段，操作DOM。这里可以访问到ref标记的DOM结构。</p> <p><strong>beforeUpdate</strong>：数据发生变化时，在虚拟DOM打补丁之前调用。可以访问数据更新前那个状态下的DOM。</p> <p><strong>updated</strong>：数据发生变化且虚拟DOM补丁打完之后。DOM更新成功，可以执行一些依赖DOM的操作。不应该在该钩子重新更改状态，考虑用watch和computed。类似mounted，不保证所有组件都重绘完成。如果需要确认所有组件重绘完成，使用$nextTick。</p> <p><strong>beforeDestroy</strong>：实例销毁之前调用。实例销毁，如v-if，vue-router中切换视图等都会触发该钩子。</p> <p><strong>destroyed</strong>：实例销毁之后调用，完全销毁，包括子实例也会销毁，同触发该钩子函数。</p> <p><strong>activated</strong>：组件相关的钩子，只有keep-alive包裹的组件，重新激活时会触发。通常我们会在<code>&lt;router-view&gt;&lt;/router-view&gt;</code>外套一层<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>，单页面应用，频繁切换视图，减小重新渲染开销。如果使用了keep-alice，会触发<code>activated</code>钩子，但是由于组件被缓存在内存中，没有销毁，也没有重新创建，因此从第二次渲染同样组件时不会触发<code>beforeCreate</code>,<code>created</code>,<code>beforeMount</code>,<code>mounted</code>等钩子，这点应该很好理解。而<code>beforeDestroy</code>,<code>destroyed</code>则永远不会被触发。</p> <p><strong>deactivated</strong>：组件相关的钩子，只有keep-alive包裹的组件，被停用时触发，类似于destroyed，但是不是真的销毁，而是存到内存放到一边，暂时不用这个组件，keep-alive形式的组件切换会触发该钩子。</p> <h2 id="路由守卫"><a href="#路由守卫" class="header-anchor">#</a> 路由守卫</h2> <p>分为3种类型守卫：全局型，单个路由独享型，组件内调用型。
通常回调函数有3个参数to, from, next。to，from均为对象，存放路由跳转目的地的参数和来源地的参数，而next为函数，类似于管道操作，进入到下一个钩子，不执行的话，通常会导致路由中断。</p> <h2 id="全局型"><a href="#全局型" class="header-anchor">#</a> 全局型</h2> <h3 id="beforeeach"><a href="#beforeeach" class="header-anchor">#</a> beforeEach</h3> <p>全局前置路由。进入某路由之前触发。</p> <h3 id="beforeresolve"><a href="#beforeresolve" class="header-anchor">#</a> beforeResolve</h3> <p>全局解析路由。导航确认之前，同时在所有组件内调用型路由守卫和异步路由组件被解析之后，该解析守卫就会被调用。这里涉及的执行条件需要理解的是，1是<code>导航确认之前</code>，导航的确认是指全部的钩子执行完，导航状态就是确认的(confirmed状态)。2是<code>组件内路由守卫和异步路由组件都被解析</code>，指的是路由内调用型的3个守卫<code>beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave</code>，异步路由组件解析后(懒加载，通过Import()函数或require方式，用到的时候会去加载再解析，没用到就不存在加载解析一说)。简单来说，等组件内调用型守卫执行完了，异步组件也加载完了，才会执行<code>beforeResolve</code>。</p> <h3 id="aftereach"><a href="#aftereach" class="header-anchor">#</a> afterEach</h3> <p>全局后置钩子。没有next参数，可以理解，毕竟都已经后置了。在路由操作流程的最后触发。需要注意的是，这个钩子看起来是最后一个执行的钩子没错，但是在组件内调用守卫<code>beforeRouteEnter</code>的参数<code>next</code>中的回调函数，才是最后执行的，此时实例已创建好，所以可以在回调中访问到vue实例！！！</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是老大，第一个执行'</span><span class="token punctuation">)</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

router<span class="token punctuation">.</span><span class="token function">beforeResolve</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是保姆，大家都加载好，我在加载'</span><span class="token punctuation">)</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是看起来的最后一名，不过好像有一个哥们比我还靠后，这哥们是beforeRouteEnter的回调参数next'</span><span class="token punctuation">)</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>没有路由地址的情况下，上述3个全局路由会被各自执行一遍！。</p> <h2 id="单个路由独享守卫"><a href="#单个路由独享守卫" class="header-anchor">#</a> 单个路由独享守卫</h2> <h3 id="beforeenter"><a href="#beforeenter" class="header-anchor">#</a> beforeEnter</h3> <p>在路由配置里面单独配置的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token operator">:</span> <span class="token string">'/name'</span><span class="token punctuation">,</span>
      componet<span class="token operator">:</span> Name<span class="token punctuation">,</span>
      <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'进入name时调用，在组件内调用的守卫之前'</span><span class="token punctuation">)</span>
        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="组件内调用守卫"><a href="#组件内调用守卫" class="header-anchor">#</a> 组件内调用守卫</h2> <h3 id="beforerouteenter"><a href="#beforerouteenter" class="header-anchor">#</a> beforeRouteEnter</h3> <p>在渲染当前路由组件对应路由被<code>完全确认(confirm)</code>前调用。因为此时，组件实例还未被创建。所以拿不到this即组件实例。但可以通过next的回调函数拿到实例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'comp'</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'进了当前组件且在路由确认前调用'</span><span class="token punctuation">)</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteUpdate</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'进了当前组件，或在当前组件打开子路由组件父组件仍存在，但内容已经不一样了，需要更新，会调用'</span><span class="token punctuation">)</span>
    <span class="token comment">// 如 home中打开A组件，/home -&gt; /home/A。 回到home组件，/home/A -&gt; /home</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteLeave</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'离开当前路由组件对应的路由时调用'</span><span class="token punctuation">)</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="导航完整的解析流程"><a href="#导航完整的解析流程" class="header-anchor">#</a> 导航完整的解析流程</h2> <p>导航触发，肯定是从一个路由地址跳往另一个。我们这里考虑这种情况<code>/home/A -&gt; /home/B</code>，涉及到所有守卫;</p> <ol><li>触发A的<code>beforeRouteLeave</code></li> <li>触发全局的<code>beforeEach</code></li> <li>触发Home组件中的<code>beforeRouteUpdate</code></li> <li>触发B的独享路由守卫<code>beforeEnter</code></li> <li>解析异步组件</li> <li>触发B的组件级守卫<code>beforeRouteEnter</code></li> <li>触发全局的<code>beforeResolve</code></li> <li>导航确认</li> <li>触发全局的<code>afterEach</code></li> <li>触发DOM更新</li> <li>组件实例创建完成，调用<code>beforeRouterEnter</code>中传递给<code>next</code>的回调函数，回调函数可传vm，即实例对象。</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/2018/test2018/less-module-in-webpack.html" class="prev">
        less-module-in-webpack
      </a></span> <span class="next"><a href="/2018/test2018/promise.html">
        promise
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.42da6a3b.js" defer></script><script src="/assets/js/2.756098eb.js" defer></script><script src="/assets/js/17.e2888c6c.js" defer></script>
  </body>
</html>
